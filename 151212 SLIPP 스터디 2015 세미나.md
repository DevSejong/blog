# SLIPP 스터디 2015 세미나.

## 스터디를 하면서 배운것들 (박재성)

1. 지식습득(x) -> 서로의 배경없이 마음껏 떠들 수 있다.
2. 발표능력 향상
3. 어려운 책들을 함께 공부할 수 있다.
4. 사람들과 관계의 즐거움

## 평범한 서버 개발자의 최근 개발 트렌드와 소소한 이야기 (정진수)

###### 카카오에서의 개발경험.

- 서비스에 대한 자세, 멀티 플레이어, 수평문화, 훌륭한 동료, 신뢰, 충돌, 헌신 모바일게임혁명..
- 린스타트업처럼 빠르게 만들고 빠르게 출시
- 빠른개발, 짧은 코드, 오픈소붓스의 적극적인 활용, **FUN**
	- 루비 온 레일즈를 적극적으로 활용한다.
- 다양한 기술 혹은 툴을 학습하고 사용해봄으로써 따라 개인 능력을 빠르게 늘릴수 있었다.
- 다양한 글을 읽어보고 직접 코딩해보고 느낀다.
- 알아야 할 것도 많고 똑똑한 사람들도 많다. 여기서 살아나갈 수 있을까??
	- 제대로 알고 쓸려면 따라갈 수 없을지도...
	- 어느 정도 파악하고 나서 이거구나 싶으면 바로 업무에 사용해나가면서 익히는 형태로 변경
	- 꾸준한 지식습득과 연븟을 통해서 기준을 만들어나갈 수 있어야 한다.
		- 구글트랜드로 사용정도 파악하기
		- 문서화가 어느정도로 되어있는지
		- 만든사람은 누구인지
		- 얼마나 활성화되어있는 프로젝트인지
		- 레퍼런스가 얼마나 많이 있는가?
	- 자신만의 기준을 정하고, 이를 기준으로 라이브러리나 기술을 선정한다.

##### 지금... 게임개발 플랫폼을 개발하고 있다.(중국으로 진출!!)

- 성공과 실패를 떠나서, 빠르게 만들어야지 성공여부를 확인할 수 있을 것이다.
- 스칼라를 선택
	- 폴리글랏 프로그래밍에서 함수형 언어를 접함.
		- 순수 함수만을 사용한다.
		- 부수효과가 없어야 한다.
			- 모듈화를 시키고, 쉽게 확장이 가능하다.
			- 상태가 없도록 만들어야 동시성 문제를 쉽게 만들어낼 수 있다.
		- 많은 데이터를 동시에 처리하는 현대 프로그래밍 고유의 문제를 해결하는데 있어서는 함수형 프로그래밍이 필수!!
	- 낮은 진입장벽
	- 짧은코드로도 자바와 동일한 기능을 하도록 만들 수 있다.
	- 프레임워크 및 라이브러리의 안정화에 대한 이슈
		- 양날의 검. 빠르게 발전하지만 하위호환성은 부족함
- 이를 통해서 얻고자 하는것
	- 빠르게 업데이트하고
	- 빠르게 확장가능하고
	- 안정적인 서비스 운영
- 조금더 실무에서는 어떻게 적용할 수 있을까??
	- MSA를 적용하자! micro service architecture
	- 장점은??
		- 새로운 팀원 합류시에 빠르게 개발에 투입될 수 있다.
		- 서비스 확장을 예측할 수 없다. 최대한 유연한 구조를 만들수 있다.
		- DevOps에 대한 경험을 얻을 수 있다.
	- 하지만
		- 커뮤니케이션 로스가 발생하기 쉽다
		- 서로간 독립된 모듈간 독립된 개발자가 개발.
	- 힘들지만 충분히 가치가 있다!

##### 2015년 목표와 결과!

- 만들어야 할 것이 가슴뛰게 만들고
- 만드는 과정이 즐겁고
- 만들고 나면 뿌듯한
- 이를 통한 빠른 성장!!

## GO concurrency for beginners (아라한사)

##### Go를 왜 공부하게 되었는가??

- GO언어???
	- 구글에서 시작
	- 생산성이 몹시 높다라는 주장이 있다.
	- GO는 시스템 프로그래밍언어이다.
		- 기계, 하드웨어, 운영체제같은 프로그래밍이 가능하다.(자바가 유저서비스를 지향한다면...)
		- C언어와 같이 저수준 프로그래밍 언어이면서, 동시에 높은 추상화 레벨을 가진다.
		- 그렇기 때문에 도커에서는 GO를 많이 사용한다.
	- 동시성 프로그래밍.
		- 경량쓰래드 특성(적은 비용으로 즉 낮은 메모리를 사용해서 쓰래드를 구현할 수 있다. 시스템의 자원을 아낄 수 있음)

##### GO를 사용한 동시성 프로그래밍

- 동시성 프로그래밍을 정말 정말 정말 쉽게 사용할 수 있다.
	- 언어적인 차원에서 동시성에 대해서 많은 지원을 해준다.
	- 펑션 실행시 go func   --> 쓰래드 선언도 필요없음
- 채널을 통해서 쓰래드간 통신이 가능하다.
- 채널은 select를 통해 분기문으로도 사용할 수 있다.
- GO언어에서의 동시성과 데드락
	- 아토믹 변수를 기본적으로 지원한다.
	- 자바보다는 동시성을 처리.
- Data race.. 경쟁상태가 일어날수도 있는지 여부를 언어차원에서 감지한다.
	- 프로그램을 실행할 때 -race 옵션을 통해서, 안전한 프로그램인지 여부를 판단할 수 있다.

## 함수형 언어 클로저를 만나다. (양완수)

##### 대안 언어에 관심을 가지다!

- 빠른 아이디어 검증
- 운영시 적합한 도구를 뚝딱
- 먼가 있어보이고 싶다.
- LISP을 만나다
	- 컴퓨터 프로그램의 구조와 해석에서 처음을 접함
	- LISP을 좋아하는 사람들의 모임(커뮤니티)
	- ...근데 클로저를 공부한다고... 클로저는 LISP의 방언중 하나.
		- JVM위에서도 돌아간다.
	- 진입장벽이 너무 높다.
		- 이클립스도 사용하지 않고.. emacs... USB에 자기 설정을 가지고 다닌다.
		- 실제 사용자층은 공연미술, 설치미술하시던 분들
		- 친숙하지 않음.
		- 적용할 곳을 찾지 못했다.
		- 그저 단순한 호기심이였기 때문에 잘 나가지 않음.
- 양완수님의 클로저에 대한 느낌
	- 코딩이 재미있다.
	- 명령이 아닌 선언적 프로그래밍
		- if, for 처럼 명령문이 아닌, 블록을 만들고 레고를 조립하는 느낌과 닮음
	- 선언적인 사고를 통해 우연적 복잡성이 낮아진 것 같다.
	- REPL 바로바로 실행할 수 있다.
		- 하지만, 테스트 먼저의 흐름을 잃어버렸다.
	- 쉽지않다.
		- 친숙하지 않다.
		- 사용할 곳이 없었기에, 필요성이 부족했다.

##### 동시성 작업을 해본적이 있었나?

- 아직까지 한번도 없다.
- 쿼드코어 시대가 왔음에도 불구하고 우리는 스래드를 사용하지 않는다.
- 객체의 유연함은 무한대이지만, 재사용하지는 않았다.
	- 비즈니스 상황에 따라서 객체는 독립적으로 만들어낸다.
		- 스프링 시큐리티를 생각해보자.. User의 고정된 자료형은 몹시나 불편했다.
- 변화에 빠른 대응이 가능하였는가??
	- 애자일 시대
	- 신중한 설계가 오히려 발목을 잡는 경우가 많았다.
- 변화를 막을수는 없었다.
	- 기본적으로 Mutable..
	- 변화는 산개되어있기 때문에 찾기 힘들다.
	- 접근통제로 인해서 코드를 이해하기 힘들고 테스트도 쉽지 않다.
- 자바로 작성할 경우더라도 쉽게 읽을 수 없다.
	- 다른사람이 작성된 코드는 특히나.. 이해하는게 쉽지 않다.
- ORM?? 복잡하지 않나요?
	- 대부분의 프로그래밍은 데이터의 관리문제를 다룬다.
	- 영속성에 대한 고나리는 비즈니스의 복잡성이 아니다.
	- OOP에서는
		- 클린코드, SOLID
		- OO의 한계가 분명하다...
		- 우연적 복잡성(언어, 설정, 프레임워크...)이 증가한다.
		- 비즈니스는 우연적 복잡성때문에 무시당하고 있지는 않나?

##### 클로저가 정답

- 비즈니스에 대한.. 단순함으로 복귀
- 불변성
	- 불변성은 멀티스레드 호나경에서 안전하다.
- 오로지 인자로만 결과가 만들어지고 반환값으로만 외부에 영향을 준다.
- 데이터의 불변성은 부수효과를 없게 만든다.
- 부수효과가 없으면 테스트가 쉬워진다.
- 고계함수
	- 함수를 인자로 받고 동적으로!! 함수를 반환하는 함수를 다루는 함수
- 익명함수
	- 함수가 하는 일에만 충실하면 된다.
	- 인터페이스명을 외우지 않아도 된다.
- 오로지 함수와 반환되는 값에만 관심을 가진다.
- 코드의 이해도가 높아질 수 있다.
	- 개인적으로는 여전히 복잡해보이는데...
- 데이터는 시퀀스.
	- 자바에서 컬렉션이라고 부르는 것들을 모두 시퀀스라는 이름으로 추상화시킨다.
- 객체라는 것은 데이터의 집합일뿐이다.
	- 객체를 데이터의 집합으로 본다면...
	- 조합기에 의한 유연성을 보장받을 수 있다.
	- 변화에 유연해진다.
- 클로저는 필요하다면 만들어서 사용할 수 있다.
	- 매크로를 만들어 사용할 수 있다.
	- 직접 언어를 만들어낼 수 있다.
	- DSL같은것도 만들 수 있을 듯.
		- 특정 도메인에 사용되는 언어를 만들어낼 수 있을 것이다.
- (별로 장점이 아닌듯 하지만) 클로저는 자바에서 그 반대의 경우에서도 사용할 수 있다.
	- http://clojars.org
	- 필요에 따라서 OO개념도 사용할 수 있다.
- 실제로 많은 기업에서도 사용하고 있고, 받아들이는 단계를 넘어 실무에서도 많이 사용되고 있다.


## 스칼라 산책 (배유미)

- 스칼라 = **Scal**able **La**nguage
- Object Oriented
	- 모든 값은 객체이다.
	- 모든 연산은 메소드 호출이다.
	- Trait(특성)
		- 자바8의 디폴트 메서드와 비슷한 개념
		- 이 안에서 매서드와 필드를 구현할 수 있다.
		- 사용자가 직접 확장 문법을 만들어낼 수 있다.
- 스칼라에서는 immutable을 직접 지원한다.
- 자바와 비슷한 문법을 지원하면서 자바보다 쉽게 표현이 가능하다.
	- 표현력이 좋으면서 적은 문법으로도 많은 내용을 표현할 수 있다.
	- 암묵적인 문법 (";" 생략가능과 같은..)을 지원한다.
- 타입추론
	- String aa = Hello World! --> 문자열을 나타내는 '"'가 없어도 알아서 타입을 추론한다.
- 변수
	- val(변경불가능한 객체), var(변경 가능한 객체) 두가지 사용가능
- 튜플을 사용할 수 있다.
	- 형이 자유로운 맵을 만들어낼 수 있다.
- switch대신 match문법도 지원. break가 없어서 마음에 듦.

## 영속성 컨텍스트로 보는 JPA (이경원)

- leekw3747@gmail.com

##### JDBC에서 JPA로

- JDBC
	- 커넥션을 맺고, 실행하고, 커낵션을 닫는다.
- xBatis
	- 커넥션관리 매핑은 xBatis가 알아서 지원해준다.
- JPA
	- 엔티티매니저가 DB와 통신한다.
	- 자동으로 알아서 Query문을 작성한다.
- 엔티티의 생명주기
	- 비영속 단계(New)
		- persist를 사용해 영속단계로 변경
		- 이때는 엔티티컨텍스트에 정의되지 않는다.
	- 영속 단계(Managed)
		- 엔티티매니저가 관리
	- 삭제(removed)
		- 영속단계에서 remove()를 호출
	- 준영속(detached)

##### 영속성 컨텍스트

- entityManager = 영속성 컨텍스트에 접근하는 객체
- `EntityManager em1= emf.createEntityManager()`를 호출하여 영속성 컨텍스트를 생성할 수 있다.
	- SE환경에서는 호출할때마다 엔티티 매니저가 만들어지며, 스프링 환경이라면 하나의 엔티티매니저를 공유한다.
- 엔티티 컨텍스트는 DB와 연결되는 고차원적인 추상화를 제공한다.
	- 엔티티 컨텍스트 - JDBC - DB
	- 1차 캐시 영역
		- ID, Entity, Snapshot 3가지 영역으로 나누어져 있다.
	- 조회를 할 경우, DB가 아니라 1차캐시 영역을 먼저 찾음. 없을 경우에만 DB에 조회
	- SQL를 적게 호출하기 때문에 성능이 향상됨
- 수정
	- 자동변경 감지.
	- 엔티티매니저가 알아서 Entity변경을 감지한 뒤 SQL쿼리문을 생성함.
	- flush가 되는 순간 알아서 SQL문을 호출
- 영속성 컨텍스트
	- 트랜잭션 단위에서 동작
- 영속성 컨텍스트에서 merge
	- 준영속 상태에서 영속상태로 변경할 경우
	- em.clear(), em.detach(user), em.close() 를 호출할 경우, 엔티티가 변경된 상태가 DB에 저장되지 않는다.

## Scala, Spring boot, JPA의 불편하면서도 즐거운 동거(박재성)

- 자바지기
- NEXT에서 주 3일근무.. ㅠㅜ 부럽다
- 나머지 주 2일, 3개월의 나만의 서비스 만들기 결과 공유

##### scala, boot jpa를 함께 사용한 이유

- 허튼데 시간을 쓸 수 없다.
- 핵심 비즈니스 로직에 집중하고 싶다.
- 단순하고, 최소한의 코딩만 하고 있다.
- JAVA는 지겨워..
- 단순, 반보걱인 작업제거
- PLAY프레임워크도 있는데... 왜 스프링??
	- Spring, jpa를 한번에 버릴수가 없었다.
	- 하나의 변화점. scala를 채택하도록 하자
	- 변화를 싫어하는 다른 자바 개발자를 설득하기 위한 최소한의 변화
- 나름 생산성도 있더라...
	- 귀찮다!

##### JPA가 동거에 기여하는 점.

- 요구사항이 자주 변경되는 프로젝트 초반, 빠른 사이클로 설계에 대한 다양한 실험이 가능하다.
- 삽질을 빠르게 하고, 빠르게 변경해보자!
	- JPA를 사용한다면 DB구조를 알아서 설정해준다.
	- 객체를 빠르게 변경할 수 있다.
	- 피드백 사이클이 늘어날수록 빠르게 새로운 개념을 추가할 수 있다.
	- 지식축척은 더 빠른 이해를 제공하며 도메인을 더 녹여낼 수 있다.
	- 자부심과 여유시간을 더 얻을 수 있다.

##### Spring boot??!!

- 빠른 테스트
	- 임베디드 톰캣이 내장되어있다!
	- 빠르게 MVC 테스트가 가능하다.
	- @IntegrationTest라는 어노테이션
		- 임의의 포트에서 서버를 띄우고 테스트가 가능하다.
- Spring Boot Actuator
	- 다양한 시스템 정보를 조회할 수 있다.
	- spring boot admin을 사용하면 JSON이 아니라 UI로도 볼 수 있다.
	- remote shell로 cli로도 볼 수 있다.
	- 빠르게 최소한의 모니터링 환경을 제공할 수 있다.

##### Scala가 동거에 기여하는 점

- 반드시 getter, setter를 설정하지 않아도 된다.
- 언어적인 차원에서 lombok같은 기능을 제공한다.
- Domain, DTO를 분리/통합할 것에 대한 거부감이 줄어듦
    - 애매한 경계점. 경험에 따라서 판단하여야 함
- 테스트 픽스쳐를 만들기가 쉽다.
    - 스칼라에서는 네임드 파라미터가 존재한다.
    - 기본값을 설정할 수 있고 필요한 부분에 대해서만 자유롭게 변경할 수 있다
- 일부만 썼더라도.. 자바보다는 훨씬 편하더라.


##### 이렇게 사용할 경우 고려해야 할 부분

- 스칼라의 모든 기능을 활용할수는 없었다.
- 어노테이션의 문법이 약간 다르기 때문에 여기에도 익숙해져야 한다.
- 클래스의 형태가 다를경우와 같이.
	- 불편한점이 아주 없지는 않더라.
- 컴파일 시간이 너무 길다.
	- 좋은 하드웨어가 반드시 필요함

## MSA의 기본개념(강대권)

##### 이커머스에서 MSA도입사례 소개

- 이커머스는 성장이 폭발적으로 늘어나고 있는 상태.
- 모뉼러틱 아키텍쳐로 되어있는 형태
- 스케일업… CPU, 메모리를 붙여나가서 늘어나는 트래픽을 감당
	- 서버 하나로 감당하는건 한계
- 스케일아웃. 여러개의 서버를 만들어나가기 시작
	- 하지만 기능을 추가할 경우… 배포의 어려움. 30분 너머 걸리는 전체 배포
	- 변경에 대한 두려움
	- 경직된 구조
- 마이크로 서비스 아키텍쳐로 전환
- 기초적인 내용. 정리하지 않음.
